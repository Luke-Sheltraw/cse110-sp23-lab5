1. Different technologies might have different behaviors or functions in relation to how IDs and classes are assigned/used. Thus, it's important to consider the most severe restrictions while writing any code to prevent issues down the line. For instance, if you give multiple elements the same ID and then use CSS to modify the styles of that ID, all the elements will be changed. However, if you then attempt to interact with that behavior through JS (i.e. with .getElementById()), you will only get one of the elements. Sans behavior like this, it's also important to be intentional with how we name IDs and classes so that they can be readily interpreted from other files. That is, if someone is reading a CSS file they can't immediately see what HTML is being referenced. Thus, a class name like 'xyz' creates a lot more confusion than 'dropdown-wrapper'. 
2. Data attributes are developer-created attributes for HTML elements of the form 'data-name="value"'. This allows information to be attached to elements out-of-view of the user, but easily accesible to the JavaScript. They can then be accessed using .datalist.attributeName or .getAttribute('data-attributeName') in JavaScript. This provides another way for the developer to add custom microdata to elements, instead of things like 'itemprop' where that might not be appropriate. 
3. A DOM fragment is a small subtree of the DOM that exists in JavaScript. Then, when the developer wants, the changes to the subtree can be appended all at the once to the normal DOM tree. This allows for more readable code during complex changes to the DOM.
4. The Virtual DOM allows us to make more efficient changes to very large applications. Instead of having to change the DOM over and over to make changes, we can make changes to the lighter Virtual DOM and then commit those changes to the real DOM all at once. This obviously has advantages when many changes have to be made to the DOM, the DOM is very large, and/or we need to get as much performance as possible. However, for more simple applications or DOMs that don't require many changes, implementing a Virtual DOM could unneedingly add complexity.
5. JavaScript has a set of reserved words, and 'class' is already one of them (used for object-oriented programming in JS). Thus, to avoid confusion elements use .className.
6. Although both .addEventListener() and .onClick() have similar behaviors in most examples, the advantage of .addEventListener() is that there is (virtually) no limit to the number of listeners we can attach to a single element. However, if we defined .onClick() twice for one element, it will overwrite the first instance. This could therefore be potentially dangerous if we use it inside a function, and don't know precisely how the rest of the code interacts with the element in question (i.e. we could overwrite someone else's code). However, .onClick() is arguably more intuitive for new developers.
